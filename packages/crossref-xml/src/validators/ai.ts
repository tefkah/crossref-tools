import * as Primitive from './Primitive'
// Generated by ts-to-zod
import { z } from 'zod'

// Source files:
// https://data.crossref.org/schemas/AccessIndicators.xsd
export const XastAttributesSchema = z.record(z.union([z.string(), z.undefined()]).nullable())

const XastTextSchema = z.object({
  type: z.literal('text'),
  value: z.string(),
})

const XastCommentSchema = z.object({
  type: z.literal('comment'),
  value: z.string(),
})

const XastCDataSchema = z.object({
  type: z.literal('cdata'),
  value: z.string(),
})

const XastInstructionSchema = z.object({
  type: z.literal('instruction'),
  name: z.string(),
  value: z.string(),
})

const FakerXastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      z.object({
        type: z.string(),
        name: z.string().optional(),
        attributes: z.record(z.any()).optional(),
        children: z.array(z.any()),
      }),
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

const FakeXastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      FakerXastElementSchema,
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

export const XastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      FakeXastElementSchema,
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

const XastTextElementSchema = XastElementSchema.extend({
  children: z.tuple([XastTextSchema]),
})

export const LicenseRefTSchema = XastElementSchema.extend({
  name: z.string(),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      /**
       * @pattern ([hH][tT][tT][pP]|[hH][tT][tT][pP][sS]|[fF][tT][pP]):\/\/.*
       * @minLength 10
       **/
      value: z
        .string()
        .min(10)
        .regex(/([hH][tT][tT][pP]|[hH][tT][tT][pP][sS]|[fF][tT][pP]):\/\/.*/),
    }),
  ]),
})

export const LicenseRefAppliesToSchema = z.union([
  z.literal('vor'),
  z.literal('am'),
  z.literal('tdm'),
  z.literal('stm-asf'),
])

export const EndDateSchema = XastElementSchema.extend({
  name: z.string(),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const DateSchema = z.string()

export const FreeToReadSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('free_to_read'),
  attributes: z.object({
    /** A date, unknown format **/
    end_date: z.string().optional(),
    /** A date, unknown format **/
    start_date: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const LicenseRefSchema = LicenseRefTSchema.extend({
  type: z.literal('element'),
  name: z.literal('license_ref'),
  attributes: z.object({
    applies_to: LicenseRefAppliesToSchema.optional(),
    /** A date, unknown format **/
    start_date: z.string().optional(),
  }),
})

export const NameSchema = XastElementSchema.extend({
  name: z.literal('name'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Accommodates deposit of license metadata. The license_ref value will be a URL. Values for the "applies_to" attribute are vor (version of record),am (accepted manuscript), tdm (text and data mining), and stm-asf (STM Article Sharing Framework license).**/
export const ProgramSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('program'),
  attributes: z.object({
    name: z.string(),
  }),
  children: z.array(z.union([FreeToReadSchema, LicenseRefSchema])),
})

export const StartDateSchema = XastElementSchema.extend({
  name: z.string(),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})
