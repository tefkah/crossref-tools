import * as Primitive from './Primitive'
import * as xlink from './xlink'
import * as xml from './xml'
// Generated by ts-to-zod
import { z } from 'zod'
import {
  NestedKwd,
  Glossary,
  IndexTerm,
  SubjGroup,
  VerseGroup,
  SubArticle,
} from '../types/www.ncbi.nlm.nih.gov/JATS1.d'

// Source files:
// https://data.crossref.org/schemas/JATS-journalpublishing1-3d2-mathml3-elements.xsd
// https://data.crossref.org/schemas/JATS-journalpublishing1-3d2-mathml3.xsd
export const XastAttributesSchema = z.record(z.union([z.string(), z.undefined()]).nullable())

const XastTextSchema = z.object({
  type: z.literal('text'),
  value: z.string(),
})

const XastCommentSchema = z.object({
  type: z.literal('comment'),
  value: z.string(),
})

const XastCDataSchema = z.object({
  type: z.literal('cdata'),
  value: z.string(),
})

const XastInstructionSchema = z.object({
  type: z.literal('instruction'),
  name: z.string(),
  value: z.string(),
})

const FakerXastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      z.object({
        type: z.string(),
        name: z.string().optional(),
        attributes: z.record(z.any()).optional(),
        children: z.array(z.any()),
      }),
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

const FakeXastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      FakerXastElementSchema,
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

export const XastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      FakeXastElementSchema,
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

const XastTextElementSchema = XastElementSchema.extend({
  children: z.tuple([XastTextSchema]),
})

export const AbbrSchema = XastElementSchema.extend({
  name: z.literal('abbr'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const StringSchema = z.string()

/** Abbreviation or Acronym
 **/
export const AbbrevSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('abbrev'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    alt: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Abbreviated Journal Title
 **/
export const AbbrevJournaltitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('abbrev-journal-title'),
  attributes: z.object({
    abbrevType: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const AbbrevTypeSchema = XastElementSchema.extend({
  name: z.literal('abbrev-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const AbstractTypeSchema = XastElementSchema.extend({
  name: z.literal('abstract-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Access Date For Cited Work
 **/
export const AccessDateSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('access-date'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    calendar: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Address/Contact Information
 **/
export const AddressSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('address'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Address Line
 **/
export const AddrLineSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('addr-line'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Affiliation
 **/
export const AffSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('aff'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Affiliation Alternatives
 **/
export const AffAlternativesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('aff-alternatives'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(AffSchema),
})

export const ColAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const ColgroupAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const TbodyAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const TrAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const TdAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const ThAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const TfootAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const TheadAlignSchema = z.union([
  z.literal('center'),
  z.literal('char'),
  z.literal('justify'),
  z.literal('left'),
  z.literal('right'),
])

export const AltSchema = XastElementSchema.extend({
  name: z.literal('alt'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Alternatives For Processing
 **/
export const AlternativesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('alternatives'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Alternate Title Text For a Figure, Etc.
 **/
export const AltTextSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('alt-text'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Alternate Title
 **/
export const AltTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('alt-title'),
  attributes: z.object({
    altTitletype: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const AltTitletypeSchema = XastElementSchema.extend({
  name: z.literal('alt-title-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Annotation in a Citation
 **/
export const AnnotationSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('annotation'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Anonymous
 **/
export const AnonymousSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('anonymous'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SubArrangeSchema = z.union([z.literal('stack'), z.literal('stagger')])

export const SupArrangeSchema = z.union([z.literal('stack'), z.literal('stagger')])

/** Article Title
 **/
export const ArticleTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('article-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ArticleTypeSchema = XastElementSchema.extend({
  name: z.literal('article-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Article Version
 **/
export const ArticleVersionSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('article-version'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    articleVersiontype: z.string().optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    designator: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Article Version Alternatives
 **/
export const ArticleVersionalternativesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('article-version-alternatives'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(ArticleVersionSchema),
})

export const ArticleVersiontypeSchema = XastElementSchema.extend({
  name: z.literal('article-version-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const AssigningAuthoritySchema = XastElementSchema.extend({
  name: z.literal('assigning-authority'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Attribution
 **/
export const AttribSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('attrib'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const AudienceSchema = XastElementSchema.extend({
  name: z.literal('audience'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ContribIdAuthenticatedSchema = z.union([z.literal('false'), z.literal('true')])

/** Award Description
 **/
export const AwardDescSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('award-desc'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Award Identifier
 **/
export const AwardIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('award-id'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    awardIdtype: z.string().optional(),
    awardType: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const AwardIdtypeSchema = XastElementSchema.extend({
  name: z.literal('award-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Award Name
 **/
export const AwardNameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('award-name'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const AwardTypeSchema = XastElementSchema.extend({
  name: z.literal('award-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const AxisSchema = XastElementSchema.extend({
  name: z.literal('axis'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const BaselineShiftSchema = XastElementSchema.extend({
  name: z.literal('baseline-shift'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ProcessingMetaBaseTagsetSchema = z.union([
  z.literal('archiving'),
  z.literal('authoring'),
  z.literal('publishing'),
])

/** Block-Level Alternatives For Processing
 **/
export const BlockAlternativesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('block-alternatives'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const BorderSchema = XastElementSchema.extend({
  name: z.literal('border'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Line Break
 **/
export const BreakSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('break'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const CalendarSchema = XastElementSchema.extend({
  name: z.literal('calendar'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CellpaddingSchema = XastElementSchema.extend({
  name: z.literal('cellpadding'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CellspacingSchema = XastElementSchema.extend({
  name: z.literal('cellspacing'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Chapter Title in a Citation
 **/
export const ChapterTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('chapter-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const CharSchema = XastElementSchema.extend({
  name: z.literal('char'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CharoffSchema = XastElementSchema.extend({
  name: z.literal('charoff'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Chemical Structure (Display)
 **/
export const ChemStructSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('chem-struct'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Citation Alternatives
 **/
export const CitationAlternativesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('citation-alternatives'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** City: in an Address
 **/
export const CitySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('city'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const CodeTypeSchema = XastElementSchema.extend({
  name: z.literal('code-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CodeVersionSchema = XastElementSchema.extend({
  name: z.literal('code-version'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Collaborative (Group) Author
 **/
export const CollabSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('collab'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    collabType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    symbol: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Collaboration Alternatives
 **/
export const CollabAlternativesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('collab-alternatives'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const CollabTypeSchema = XastElementSchema.extend({
  name: z.literal('collab-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ColspanSchema = XastElementSchema.extend({
  name: z.literal('colspan'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Comment in a Citation
 **/
export const CommentSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('comment'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Compound Keyword Part
 **/
export const CompoundKwdpartSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('compound-kwd-part'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Compound Subject Part Name
 **/
export const CompoundSubjectpartSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('compound-subject-part'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Conference Acronym
 **/
export const ConfAcronymSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conf-acronym'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Conference Date
 **/
export const ConfDateSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conf-date'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    calendar: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Conference Location
 **/
export const ConfLocSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conf-loc'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Conference Name
 **/
export const ConfNameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conf-name'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Conference Number
 **/
export const ConfNumSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conf-num'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Conference Sponsor
 **/
export const ConfSponsorSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conf-sponsor'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Conference Theme
 **/
export const ConfThemeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conf-theme'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ContentTypeSchema = XastElementSchema.extend({
  name: z.literal('content-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ContinuedFromSchema = XastElementSchema.extend({
  name: z.literal('continued-from'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Contributor Group
 **/
export const ContribGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('contrib-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Contributor Identifier
 **/
export const ContribIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('contrib-id'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    authenticated: ContribIdAuthenticatedSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    contribIdtype: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ContribIdtypeSchema = XastElementSchema.extend({
  name: z.literal('contrib-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ContribTypeSchema = XastElementSchema.extend({
  name: z.literal('contrib-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Copyright Holder
 **/
export const CopyrightHolderSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('copyright-holder'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Copyright Statement
 **/
export const CopyrightStatementSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('copyright-statement'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Copyright Year
 **/
export const CopyrightYearSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('copyright-year'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const OptionCorrectSchema = z.union([z.literal('no'), z.literal('yes')])

export const ContribCorrespSchema = z.union([z.literal('no'), z.literal('yes')])

/** Correspondence Information
 **/
export const CorrespSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('corresp'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Count
 **/
export const CountSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('count'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    count: z.string(),
    countType: z.string(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const CountrySchema = XastElementSchema.extend({
  name: z.literal('country'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CountTypeSchema = XastElementSchema.extend({
  name: z.literal('count-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CurrencySchema = XastElementSchema.extend({
  name: z.literal('currency'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CustomTypeSchema = XastElementSchema.extend({
  name: z.literal('custom-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Data Title in a Citation
 **/
export const DataTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('data-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Date Inside Citation
 **/
export const DateIncitationSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('date-in-citation'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    calendar: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const DateTypeSchema = XastElementSchema.extend({
  name: z.literal('date-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Day
 **/
export const DaySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('day'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ContribDeceasedSchema = z.union([z.literal('no'), z.literal('yes')])

/** Definition List: Definition
 **/
export const DefSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('def'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Definition List: Definition Head
 **/
export const DefHeadSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('def-head'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const DegreeContributionSchema = XastElementSchema.extend({
  name: z.literal('degree-contribution'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Degree(s)
 **/
export const DegreesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('degrees'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const DescriptionSchema = XastElementSchema.extend({
  name: z.literal('description'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const DesignatorSchema = XastElementSchema.extend({
  name: z.literal('designator'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Formula, Display
 **/
export const DispFormulaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('disp-formula'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const DocumentIdSchema = XastElementSchema.extend({
  name: z.literal('document-id'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const DocumentIdtypeSchema = XastElementSchema.extend({
  name: z.literal('document-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const DocumentTypeSchema = XastElementSchema.extend({
  name: z.literal('document-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ArticleDtdVersionSchema = z.union([
  z.literal('0.4'),
  z.literal('1.0'),
  z.literal('1.1'),
  z.literal('1.1d1'),
  z.literal('1.1d2'),
  z.literal('1.1d3'),
  z.literal('1.2'),
  z.literal('1.2d1'),
  z.literal('1.2d2'),
  z.literal('1.3d1'),
  z.literal('1.3d2'),
  z.literal('3.0'),
])

/** Edition Statement, Cited
 **/
export const EditionSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('edition'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    designator: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Element Citation
 **/
export const ElementCitationSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('element-citation'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    publicationFormat: z.string().optional(),
    publicationType: z.string().optional(),
    publisherType: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    useType: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Electronic Location Identifier
 **/
export const ElocationIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('elocation-id'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    seq: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Email Address
 **/
export const EmailSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('email'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ContribEqualContribSchema = z.union([z.literal('no'), z.literal('yes')])

/** Equation Count
 **/
export const EquationCountSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('equation-count'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    count: z.string(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Era
 **/
export const EraSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('era'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Et Al
 **/
export const EtalSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('etal'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Event Description
 **/
export const EventDescSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('event-desc'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const EventTypeSchema = XastElementSchema.extend({
  name: z.literal('event-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const CodeExecutableSchema = z.union([z.literal('no'), z.literal('yes')])

/** Extended-by Model
 **/
export const ExtendedBySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('extended-by'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    designator: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** External Link
 **/
export const ExtLinkSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('ext-link'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    extLinktype: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ExtLinktypeSchema = XastElementSchema.extend({
  name: z.literal('ext-link-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Fax Number: in an Address
 **/
export const FaxSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fax'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Figure Count
 **/
export const FigCountSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fig-count'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    count: z.string(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const FigTypeSchema = XastElementSchema.extend({
  name: z.literal('fig-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Fixed Case
 **/
export const FixedCaseSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fixed-case'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Floats Group
 **/
export const FloatsGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('floats-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const FnFnTypeSchema = z.union([
  z.literal('abbr'),
  z.literal('coi-statement'),
  z.literal('com'),
  z.literal('con'),
  z.literal('conflict'),
  z.literal('corresp'),
  z.literal('current-aff'),
  z.literal('custom'),
  z.literal('deceased'),
  z.literal('edited-by'),
  z.literal('equal'),
  z.literal('financial-disclosure'),
  z.literal('on-leave'),
  z.literal('other'),
  z.literal('participating-researchers'),
  z.literal('present-address'),
  z.literal('presented-at'),
  z.literal('presented-by'),
  z.literal('previously-at'),
  z.literal('study-group-members'),
  z.literal('supplementary-material'),
  z.literal('supported-by'),
])

export const FontcharSchema = XastElementSchema.extend({
  name: z.literal('fontchar'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const FontnameSchema = XastElementSchema.extend({
  name: z.literal('fontname'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const FormatSchema = XastElementSchema.extend({
  name: z.literal('format'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** First Page
 **/
export const FpageSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fpage'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    seq: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const TableFrameSchema = z.union([
  z.literal('above'),
  z.literal('below'),
  z.literal('border'),
  z.literal('box'),
  z.literal('hsides'),
  z.literal('lhs'),
  z.literal('rhs'),
  z.literal('void'),
  z.literal('vsides'),
])

/** Funding Source
 **/
export const FundingSourceSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('funding-source'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    country: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    sourceType: z.string().optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Funding Statement
 **/
export const FundingStatementSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('funding-statement'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Given (First) Names
 **/
export const GivenNamesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('given-names'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    initials: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Glyph Data For a Private Character
 **/
export const GlyphDataSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('glyph-data'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    fontchar: z.string().optional(),
    fontname: z.string().optional(),
    format: z.string().optional(),
    id: z.string().optional(),
    resolution: z.string().optional(),
    /** space (as an attribute name)
     * denotes an attribute whose
     * value is a keyword indicating what whitespace processing
     * discipline is intended for the content of the element; its
     * value is inherited.  This name is reserved by virtue of its
     * definition in the XML specification.
     **/
    space: xml.SpaceSchema,
    xSize: z.string().optional(),
    ySize: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Glyph Reference For a Private Character
 **/
export const GlyphRefSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('glyph-ref'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    glyphData: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Government Report, Cited
 **/
export const GovSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('gov'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const HeadersSchema = XastElementSchema.extend({
  name: z.literal('headers'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** History: Document History
 **/
export const HistorySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('history'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Horizontal Rule
 **/
export const HrSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('hr'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const HreflangSchema = XastElementSchema.extend({
  name: z.literal('hreflang'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const IdSchema = XastElementSchema.extend({
  name: z.literal('id'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const IndentLevelSchema = XastElementSchema.extend({
  name: z.literal('indent-level'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Index Term Range End
 **/
export const IndexTermrangeendSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('index-term-range-end'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    rid: z.string(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const IndexTypeSchema = XastElementSchema.extend({
  name: z.literal('index-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const InitialsSchema = XastElementSchema.extend({
  name: z.literal('initials'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Formula, Inline
 **/
export const InlineFormulaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('inline-formula'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Inline Graphic
 **/
export const InlineGraphicSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('inline-graphic'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    baselineShift: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    mimeSubtype: z.string().optional(),
    mimetype: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Inline Media Object
 **/
export const InlineMediaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('inline-media'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    mimeSubtype: z.string().optional(),
    mimetype: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Inline Supplementary Material
 **/
export const InlineSupplementarymaterialSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('inline-supplementary-material'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    mimeSubtype: z.string().optional(),
    mimetype: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Institution Name: in an Address
 **/
export const InstitutionSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('institution'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Institution Identifier
 **/
export const InstitutionIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('institution-id'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    institutionIdtype: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const InstitutionIdtypeSchema = XastElementSchema.extend({
  name: z.literal('institution-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Institution Wrapper
 **/
export const InstitutionWrapSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('institution-wrap'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Isbn
 **/
export const IsbnSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('isbn'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    publicationFormat: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const Iso8601DateSchema = XastElementSchema.extend({
  name: z.literal('iso-8601-date'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Issn
 **/
export const IssnSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issn'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    pubType: z.string().optional(),
    publicationFormat: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Issn Linking
 **/
export const IssnLSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issn-l'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Issue Number
 **/
export const IssueSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issue'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    seq: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Issue Identifier
 **/
export const IssueIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issue-id'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    pubIdtype: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Issue Part
 **/
export const IssuePartSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issue-part'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Issue Title
 **/
export const IssueSponsorSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issue-sponsor'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Issue Subtitle
 **/
export const IssueSubtitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issue-subtitle'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Issue Title
 **/
export const IssueTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issue-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Journal Identifier
 **/
export const JournalIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('journal-id'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    journalIdtype: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const JournalIdtypeSchema = XastElementSchema.extend({
  name: z.literal('journal-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Journal Subtitle
 **/
export const JournalSubtitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('journal-subtitle'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Journal Title (Full)
 **/
export const JournalTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('journal-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Keyword
 **/
export const KwdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('kwd'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const KwdGrouptypeSchema = XastElementSchema.extend({
  name: z.literal('kwd-group-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Label of a Figure, Reference, Etc.
 **/
export const LabelSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('label'),
  attributes: z.object({
    alt: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const LanguageSchema = XastElementSchema.extend({
  name: z.literal('language'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const LanguageVersionSchema = XastElementSchema.extend({
  name: z.literal('language-version'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** License Information
 **/
export const LicenseSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('license'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    licenseType: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** License Paragraph
 **/
export const LicensePSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('license-p'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const LicenseTypeSchema = XastElementSchema.extend({
  name: z.literal('license-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const LinkTypeSchema = XastElementSchema.extend({
  name: z.literal('link-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ListContentSchema = XastElementSchema.extend({
  name: z.literal('list-content'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ListTypeSchema = XastElementSchema.extend({
  name: z.literal('list-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Long Description
 **/
export const LongDescSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('long-desc'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Last Page
 **/
export const LpageSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('lpage'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ProcessingMetaMathmlVersionSchema = z.union([z.literal('2.0'), z.literal('3.0')])

export const MathRepresentationSchema = XastElementSchema.extend({
  name: z.literal('math-representation'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Metadata Data Name For Custom Metadata
 **/
export const MetaNameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('meta-name'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Metadata Data Value For Custom Metadata
 **/
export const MetaValueSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('meta-value'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Milestone End
 **/
export const MilestoneEndSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('milestone-end'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rationale: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Milestone Start
 **/
export const MilestoneStartSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('milestone-start'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rationale: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const MimeSubtypeSchema = XastElementSchema.extend({
  name: z.literal('mime-subtype'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const MimetypeSchema = XastElementSchema.extend({
  name: z.literal('mimetype'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Mixed Citation
 **/
export const MixedCitationSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('mixed-citation'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    publicationFormat: z.string().optional(),
    publicationType: z.string().optional(),
    publisherType: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    useType: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Month
 **/
export const MonthSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('month'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Name Alternatives
 **/
export const NameAlternativesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('name-alternatives'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Named Special (Subject) Content
 **/
export const NamedContentSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('named-content'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    alt: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const NameNameStyleSchema = z.union([
  z.literal('eastern'),
  z.literal('given-only'),
  z.literal('islensk'),
  z.literal('western'),
])

export const StringNameNameStyleSchema = z.union([
  z.literal('eastern'),
  z.literal('given-only'),
  z.literal('islensk'),
  z.literal('western'),
])

/** Nested Keyword
 **/
export const NestedKwdSchema: z.ZodSchema<NestedKwd> = z.lazy(() =>
  XastElementSchema.extend({
    type: z.literal('element'),
    name: z.literal('nested-kwd'),
    attributes: z.object({
      assigningAuthority: z.string().optional(),
      /** base (as an attribute name)
       * denotes an attribute whose value
       * provides a URI to be used as the base for interpreting any
       * relative URIs in the scope of the element on which it
       * appears; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML Base specification.
       * See http://www.w3.org/TR/xmlbase/
       * for information about this attribute.
       **/
      base: z.string().optional(),
      contentType: z.string().optional(),
      id: z.string().optional(),
      vocab: z.string().optional(),
      vocabIdentifier: z.string().optional(),
      vocabTerm: z.string().optional(),
      vocabTermidentifier: z.string().optional(),
    }),
    children: z.array(NestedKwdSchema),
  }),
)

export const TexMathNotationSchema = z.union([
  z.literal('LaTeX'),
  z.literal('TEX'),
  z.literal('TeX'),
  z.literal('tex'),
])

/** Note in a Reference List
 **/
export const NoteSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('note'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(LabelSchema),
})

export const NotesTypeSchema = XastElementSchema.extend({
  name: z.literal('notes-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Object Identifier
 **/
export const ObjectIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('object-id'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    pubIdtype: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ObjectIdtypeSchema = XastElementSchema.extend({
  name: z.literal('object-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ObjectTypeSchema = XastElementSchema.extend({
  name: z.literal('object-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** On Behalf of
 **/
export const OnBehalfofSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('on-behalf-of'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Open Access
 **/
export const OpenAccessSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('open-access'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ArrayOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const SupplementaryMaterialOrientationSchema = z.union([
  z.literal('landscape'),
  z.literal('portrait'),
])

export const BoxedTextOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const ChemStructwrapOrientationSchema = z.union([
  z.literal('landscape'),
  z.literal('portrait'),
])

export const CodeOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const FigOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const FigGroupOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const GraphicOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const MediaOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const PreformatOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const TableWrapOrientationSchema = z.union([z.literal('landscape'), z.literal('portrait')])

export const TableWrapgroupOrientationSchema = z.union([
  z.literal('landscape'),
  z.literal('portrait'),
])

/** Overline End
 **/
export const OverlineEndSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('overline-end'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    rid: z.string(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Overline Start
 **/
export const OverlineStartSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('overline-start'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Paragraph
 **/
export const PSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('p'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const PageSchema = XastElementSchema.extend({
  name: z.literal('page'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Page Count
 **/
export const PageCountSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('page-count'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    count: z.string(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Page Ranges
 **/
export const PageRangeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('page-range'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Part Title in a Citation
 **/
export const PartTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('part-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Patent Number, Cited
 **/
export const PatentSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('patent'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    country: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Permissions
 **/
export const PermissionsSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('permissions'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(
    z.union([CopyrightHolderSchema, CopyrightStatementSchema, CopyrightYearSchema]),
  ),
})

export const PersonGroupPersonGrouptypeSchema = z.union([
  z.literal('allauthors'),
  z.literal('assignee'),
  z.literal('author'),
  z.literal('compiler'),
  z.literal('curator'),
  z.literal('custom'),
  z.literal('director'),
  z.literal('editor'),
  z.literal('guest-editor'),
  z.literal('illustrator'),
  z.literal('inventor'),
  z.literal('research-assistant'),
  z.literal('transed'),
  z.literal('translator'),
])

/** Phone Number: in an Address
 **/
export const PhoneSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('phone'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const PlatformsSchema = XastElementSchema.extend({
  name: z.literal('platforms'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const PointerToexplainedSchema = XastElementSchema.extend({
  name: z.literal('pointer-to-explained'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const PointerToquestionSchema = XastElementSchema.extend({
  name: z.literal('pointer-to-question'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const SupplementaryMaterialPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const BoxedTextPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const ChemStructwrapPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const CodePositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const FigPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const FigGroupPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const GraphicPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const MediaPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const PreformatPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const TableWrapPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

export const TableWrapgroupPositionSchema = z.union([
  z.literal('anchor'),
  z.literal('background'),
  z.literal('float'),
  z.literal('margin'),
])

/** Postal Code: in an Address
 **/
export const PostalCodeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('postal-code'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Prefix
 **/
export const PrefixSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('prefix'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const PrefixWordSchema = XastElementSchema.extend({
  name: z.literal('prefix-word'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Preformatted Text
 **/
export const PreformatSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('preformat'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: PreformatOrientationSchema.optional(),
    position: PreformatPositionSchema.optional(),
    preformatType: z.string().optional(),
    /** space (as an attribute name)
     * denotes an attribute whose
     * value is a keyword indicating what whitespace processing
     * discipline is intended for the content of the element; its
     * value is inherited.  This name is reserved by virtue of its
     * definition in the XML specification.
     **/
    space: xml.SpaceSchema,
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const PreformatTypeSchema = XastElementSchema.extend({
  name: z.literal('preformat-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Price
 **/
export const PriceSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('price'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    currency: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Principal Award Recipient
 **/
export const PrincipalAwardrecipientSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('principal-award-recipient'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Principal Investigator Recipient
 **/
export const PrincipalInvestigatorSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('principal-investigator'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Private Character (Custom or Unicode)
 **/
export const PrivateCharSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('private-char'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    description: z.string().optional(),
    id: z.string().optional(),
    name: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(InlineGraphicSchema),
})

/** Product Information
 **/
export const ProductSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('product'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    productType: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ProductTypeSchema = XastElementSchema.extend({
  name: z.literal('product-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Date Not Available Flag
 **/
export const PubDatenotavailableSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('pub-date-not-available'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Publication History
 **/
export const PubHistorySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('pub-history'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ArticleIdPubIdtypeSchema = z.union([
  z.literal('accession'),
  z.literal('archive'),
  z.literal('ark'),
  z.literal('art-access-id'),
  z.literal('arxiv'),
  z.literal('coden'),
  z.literal('custom'),
  z.literal('doaj'),
  z.literal('doi'),
  z.literal('handle'),
  z.literal('index'),
  z.literal('isbn'),
  z.literal('manuscript'),
  z.literal('medline'),
  z.literal('mr'),
  z.literal('other'),
  z.literal('pii'),
  z.literal('pmcid'),
  z.literal('pmid'),
  z.literal('publisher-id'),
  z.literal('sici'),
  z.literal('std-designation'),
  z.literal('zbl'),
])

export const PubIdtypeSchema = XastElementSchema.extend({
  name: z.literal('pub-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const PubIdPubIdtypeSchema = z.union([
  z.literal('accession'),
  z.literal('archive'),
  z.literal('ark'),
  z.literal('art-access-id'),
  z.literal('arxiv'),
  z.literal('coden'),
  z.literal('custom'),
  z.literal('doaj'),
  z.literal('doi'),
  z.literal('handle'),
  z.literal('index'),
  z.literal('isbn'),
  z.literal('manuscript'),
  z.literal('medline'),
  z.literal('mr'),
  z.literal('other'),
  z.literal('pii'),
  z.literal('pmcid'),
  z.literal('pmid'),
  z.literal('publisher-id'),
  z.literal('sici'),
  z.literal('std-designation'),
  z.literal('zbl'),
])

export const PublicationFormatSchema = XastElementSchema.extend({
  name: z.literal('publication-format'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const PublicationTypeSchema = XastElementSchema.extend({
  name: z.literal('publication-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Publisher
 **/
export const PublisherSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('publisher'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Publisher's Location
 **/
export const PublisherLocSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('publisher-loc'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Publisher's Name
 **/
export const PublisherNameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('publisher-name'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const PublisherTypeSchema = XastElementSchema.extend({
  name: z.literal('publisher-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const PubTypeSchema = XastElementSchema.extend({
  name: z.literal('pub-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const QuestionQuestionResponsetypeSchema = z.union([
  z.literal('essay'),
  z.literal('fill-in-the-blank'),
  z.literal('multi-select'),
  z.literal('multiple-choice'),
  z.literal('short-answer'),
  z.literal('true-false'),
])

export const RationaleSchema = XastElementSchema.extend({
  name: z.literal('rationale'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Ruby Base
 **/
export const RbSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('rb'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Reference Item
 **/
export const RefSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('ref'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(LabelSchema),
})

/** Reference Count
 **/
export const RefCountSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('ref-count'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    count: z.string(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const XrefRefTypeSchema = z.union([
  z.literal('aff'),
  z.literal('app'),
  z.literal('author-notes'),
  z.literal('award'),
  z.literal('bibr'),
  z.literal('bio'),
  z.literal('boxed-text'),
  z.literal('chem'),
  z.literal('collab'),
  z.literal('contrib'),
  z.literal('corresp'),
  z.literal('custom'),
  z.literal('disp-formula'),
  z.literal('fig'),
  z.literal('fn'),
  z.literal('kwd'),
  z.literal('list'),
  z.literal('other'),
  z.literal('plate'),
  z.literal('scheme'),
  z.literal('sec'),
  z.literal('statement'),
  z.literal('supplementary-material'),
  z.literal('table'),
  z.literal('table-fn'),
])

/** Related Article Information
 **/
export const RelatedArticleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('related-article'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    elocationId: z.string().optional(),
    extLinktype: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    issue: z.string().optional(),
    journalId: z.string().optional(),
    journalIdtype: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    page: z.string().optional(),
    relatedArticletype: z.string(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    vol: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const RelatedArticletypeSchema = XastElementSchema.extend({
  name: z.literal('related-article-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Related Object Information
 **/
export const RelatedObjectSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('related-object'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    documentId: z.string().optional(),
    documentIdtype: z.string().optional(),
    documentType: z.string().optional(),
    extLinktype: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    linkType: z.string().optional(),
    objectId: z.string().optional(),
    objectIdtype: z.string().optional(),
    objectType: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    sourceId: z.string().optional(),
    sourceIdtype: z.string().optional(),
    sourceType: z.string().optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ResolutionSchema = XastElementSchema.extend({
  name: z.literal('resolution'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Resource Group
 **/
export const ResourceGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('resource-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Resource Identifier
 **/
export const ResourceIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('resource-id'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    resourceIdtype: z.string().optional(),
    specificUse: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ResourceIdtypeSchema = XastElementSchema.extend({
  name: z.literal('resource-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Resource Name
 **/
export const ResourceNameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('resource-name'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ResourceTypeSchema = XastElementSchema.extend({
  name: z.literal('resource-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Resource Wrap
 **/
export const ResourceWrapSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('resource-wrap'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(z.union([ResourceIdSchema, ResourceNameSchema])),
})

export const ResponseTypeSchema = XastElementSchema.extend({
  name: z.literal('response-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Restricted-by Model
 **/
export const RestrictedBySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('restricted-by'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    designator: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const RidSchema = XastElementSchema.extend({
  name: z.literal('rid'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Role or Function Title of Contributor
 **/
export const RoleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('role'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    degreeContribution: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const RowspanSchema = XastElementSchema.extend({
  name: z.literal('rowspan'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Ruby Parenthesis
 **/
export const RpSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('rp'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Ruby Textual Annotation
 **/
export const RtSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('rt'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Ruby Wrapper
 **/
export const RubySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('ruby'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([RbSchema, RtSchema])),
})

export const TableRulesSchema = z.union([
  z.literal('all'),
  z.literal('cols'),
  z.literal('groups'),
  z.literal('none'),
  z.literal('rows'),
])

export const TdScopeSchema = z.union([
  z.literal('col'),
  z.literal('colgroup'),
  z.literal('row'),
  z.literal('rowgroup'),
])

export const ThScopeSchema = z.union([
  z.literal('col'),
  z.literal('colgroup'),
  z.literal('row'),
  z.literal('rowgroup'),
])

/** Season
 **/
export const SeasonSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('season'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Section Metadata
 **/
export const SecMetaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sec-meta'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(PermissionsSchema),
})

export const SecTypeSchema = XastElementSchema.extend({
  name: z.literal('sec-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** See
 **/
export const SeeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('see'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** See-Also Term
 **/
export const SeeAlsoSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('see-also'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Uri For This Same Article Online
 **/
export const SelfUriSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('self-uri'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SeqSchema = XastElementSchema.extend({
  name: z.literal('seq'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Series
 **/
export const SeriesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('series'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Series Text: Header Text to Describe
 **/
export const SeriesTextSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('series-text'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Series Title
 **/
export const SeriesTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('series-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Signature
 **/
export const SigSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sig'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Signature Block
 **/
export const SigBlockSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sig-block'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Size
 **/
export const SizeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('size'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    units: z.string(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Source
 **/
export const SourceSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('source'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SourceIdSchema = XastElementSchema.extend({
  name: z.literal('source-id'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const SourceIdtypeSchema = XastElementSchema.extend({
  name: z.literal('source-id-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const SourceTypeSchema = XastElementSchema.extend({
  name: z.literal('source-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const SpanSchema = XastElementSchema.extend({
  name: z.literal('span'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Speaker
 **/
export const SpeakerSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('speaker'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SpecificUseSchema = XastElementSchema.extend({
  name: z.literal('specific-use'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Speech
 **/
export const SpeechSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('speech'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(SpeakerSchema),
})

/** State or Province: in an Address
 **/
export const StateSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('state'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Standard, Cited
 **/
export const StdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('std'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Standards Organization
 **/
export const StdOrganizationSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('std-organization'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** String Conference Name
 **/
export const StringConfSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('string-conf'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Date As a String
 **/
export const StringDateSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('string-date'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    calendar: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Name of Person (Unstructured)
 **/
export const StringNameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('string-name'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    nameStyle: StringNameNameStyleSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const StyleSchema = XastElementSchema.extend({
  name: z.literal('style'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const StyleDetailSchema = XastElementSchema.extend({
  name: z.literal('style-detail'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const StyleTypeSchema = XastElementSchema.extend({
  name: z.literal('style-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Subscript
 **/
export const SubSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sub'),
  attributes: z.object({
    arrange: SubArrangeSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Subject Name
 **/
export const SubjectSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('subject'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SubjGrouptypeSchema = XastElementSchema.extend({
  name: z.literal('subj-group-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Article Subtitle
 **/
export const SubtitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('subtitle'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Suffix
 **/
export const SuffixSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('suffix'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SummarySchema = XastElementSchema.extend({
  name: z.literal('summary'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Superscript
 **/
export const SupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sup'),
  attributes: z.object({
    arrange: SupArrangeSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Supplement
 **/
export const SupplementSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('supplement'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    supplementType: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Supplementary Material
 **/
export const SupplementaryMaterialSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('supplementary-material'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    mimeSubtype: z.string().optional(),
    mimetype: z.string().optional(),
    orientation: SupplementaryMaterialOrientationSchema.optional(),
    position: SupplementaryMaterialPositionSchema.optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SupplementTypeSchema = XastElementSchema.extend({
  name: z.literal('supplement-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Support Description
 **/
export const SupportDescriptionSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('support-description'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Support Source
 **/
export const SupportSourceSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('support-source'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    country: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    supportType: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SupportTypeSchema = XastElementSchema.extend({
  name: z.literal('support-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Surname
 **/
export const SurnameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('surname'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    initials: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SymbolSchema = XastElementSchema.extend({
  name: z.literal('symbol'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Table Count
 **/
export const TableCountSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('table-count'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    count: z.string(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ProcessingMetaTableModelSchema = z.union([
  z.literal('both'),
  z.literal('none'),
  z.literal('oasis'),
  z.literal('xhtml'),
])

/** Table Wrapper
 **/
export const TableWrapSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('table-wrap'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: TableWrapOrientationSchema.optional(),
    position: TableWrapPositionSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Table Wrapper Group
 **/
export const TableWrapgroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('table-wrap-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: TableWrapgroupOrientationSchema.optional(),
    position: TableWrapgroupPositionSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ProcessingMetaTagsetFamilySchema = z.union([
  z.literal('bits'),
  z.literal('jats'),
  z.literal('sts'),
])

/** Target of an Internal Link
 **/
export const TargetSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('target'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    targetType: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const TargetTypeSchema = XastElementSchema.extend({
  name: z.literal('target-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Definition List: Term
 **/
export const TermSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('term'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
    termStatus: z.string().optional(),
    termType: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Definition List: Term Head
 **/
export const TermHeadSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('term-head'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const TermStatusSchema = XastElementSchema.extend({
  name: z.literal('term-status'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const TermTypeSchema = XastElementSchema.extend({
  name: z.literal('term-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Tex Math Equation
 **/
export const TexMathSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('tex-math'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    notation: TexMathNotationSchema.optional(),
    specificUse: z.string().optional(),
    version: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Textual Form
 **/
export const TextualFormSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('textual-form'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Time Stamp For Cited Work
 **/
export const TimeStampSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('time-stamp'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Title
 **/
export const TitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const BoldToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const ItalicToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const MonospaceToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const OverlineToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const RomanToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const SansSerifToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const ScToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const StrikeToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const StyledContentToggleSchema = z.union([z.literal('no'), z.literal('yes')])

export const UnderlineToggleSchema = z.union([z.literal('no'), z.literal('yes')])

/** Translated Abstract
 **/
export const TransAbstractSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('trans-abstract'),
  attributes: z.object({
    abstractType: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Translated Source
 **/
export const TransSourceSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('trans-source'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Translated Subtitle
 **/
export const TransSubtitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('trans-subtitle'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Translated Title
 **/
export const TransTitleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('trans-title'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Translated Title Group
 **/
export const TransTitlegroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('trans-title-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([TransSubtitleSchema, TransTitleSchema])),
})

/** Underline
 **/
export const UnderlineSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('underline'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: UnderlineToggleSchema.optional(),
    underlineStyle: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Underline End
 **/
export const UnderlineEndSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('underline-end'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    rid: z.string(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Underline Start
 **/
export const UnderlineStartSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('underline-start'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const UnderlineStyleSchema = XastElementSchema.extend({
  name: z.literal('underline-style'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const UnitsSchema = XastElementSchema.extend({
  name: z.literal('units'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Unstructured Keyword Group
 **/
export const UnstructuredKwdgroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('unstructured-kwd-group'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    kwdGrouptype: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Uri
 **/
export const UriSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('uri'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const UseTypeSchema = XastElementSchema.extend({
  name: z.literal('use-type'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const ColValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

export const ColgroupValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

export const TbodyValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

export const TrValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

export const TdValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

export const ThValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

export const TfootValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

export const TheadValignSchema = z.union([
  z.literal('baseline'),
  z.literal('bottom'),
  z.literal('middle'),
  z.literal('top'),
])

/** Line of a Verse
 **/
export const VerseLineSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('verse-line'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    indentLevel: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    style: z.string().optional(),
    styleDetail: z.string().optional(),
    styleType: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const VersionSchema = XastElementSchema.extend({
  name: z.literal('version'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const VocabSchema = XastElementSchema.extend({
  name: z.literal('vocab'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const VocabIdentifierSchema = XastElementSchema.extend({
  name: z.literal('vocab-identifier'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const VocabTermSchema = XastElementSchema.extend({
  name: z.literal('vocab-term'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const VocabTermidentifierSchema = XastElementSchema.extend({
  name: z.literal('vocab-term-identifier'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

export const VolSchema = XastElementSchema.extend({
  name: z.literal('vol'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Volume Number
 **/
export const VolumeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('volume'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    seq: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Volume Identifier
 **/
export const VolumeIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('volume-id'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    pubIdtype: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Volume Series
 **/
export const VolumeSeriesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('volume-series'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const WidthSchema = XastElementSchema.extend({
  name: z.literal('width'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Word Count
 **/
export const WordCountSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('word-count'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    count: z.string(),
    id: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** X - Generated Text and Punctuation
 **/
export const XSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('x'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    /** space (as an attribute name)
     * denotes an attribute whose
     * value is a keyword indicating what whitespace processing
     * discipline is intended for the content of the element; its
     * value is inherited.  This name is reserved by virtue of its
     * definition in the XML specification.
     **/
    space: xml.SpaceSchema,
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** X(cross) Reference
 **/
export const XrefSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('xref'),
  attributes: z.object({
    alt: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    customType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    refType: XrefRefTypeSchema.optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const XSizeSchema = XastElementSchema.extend({
  name: z.literal('x-size'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Year
 **/
export const YearSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('year'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    calendar: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const YSizeSchema = XastElementSchema.extend({
  name: z.literal('y-size'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** Abstract
 **/
export const AbstractSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('abstract'),
  attributes: z.object({
    abstractType: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Acknowledgments
 **/
export const AckSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('ack'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Appendix
 **/
export const AppSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('app'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([PermissionsSchema, SecMetaSchema, TitleSchema])),
})

/** Appendix Group
 **/
export const AppGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('app-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Array (Simple Tabular Array)
 **/
export const ArraySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('array'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: ArrayOrientationSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Article Identifier
 **/
export const ArticleIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('article-id'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    customType: z.string().optional(),
    id: z.string().optional(),
    pubIdtype: ArticleIdPubIdtypeSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Author Comment
 **/
export const AuthorCommentSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('author-comment'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(TitleSchema),
})

/** Author Note Group
 **/
export const AuthorNotesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('author-notes'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    rid: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Award Group
 **/
export const AwardGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('award-group'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    awardType: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  children: z.array(
    z.union([
      AwardDescSchema,
      AwardIdSchema,
      AwardNameSchema,
      FundingSourceSchema,
      PrincipalAwardrecipientSchema,
      PrincipalInvestigatorSchema,
      SupportSourceSchema,
    ]),
  ),
})

/** Back Matter
 **/
export const BackSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('back'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Biography
 **/
export const BioSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('bio'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    rid: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  children: z.array(z.union([LabelSchema, SecMetaSchema, TitleSchema])),
})

/** Body of the Article
 **/
export const BodySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('body'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(SigBlockSchema),
})

/** Bold
 **/
export const BoldSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('bold'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: BoldToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Caption of a Figure, Table, Etc.
 **/
export const CaptionSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('caption'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    style: z.string().optional(),
  }),
  children: z.array(TitleSchema),
})

/** Chemical Structure Wrapper
 **/
export const ChemStructwrapSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('chem-struct-wrap'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: ChemStructwrapOrientationSchema.optional(),
    position: ChemStructwrapPositionSchema.optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(LabelSchema),
})

/** Code Text
 **/
export const CodeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('code'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    codeType: z.string().optional(),
    codeVersion: z.string().optional(),
    executable: CodeExecutableSchema.optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    language: z.string().optional(),
    languageVersion: z.string().optional(),
    orientation: CodeOrientationSchema.optional(),
    platforms: z.string().optional(),
    position: CodePositionSchema.optional(),
    /** space (as an attribute name)
     * denotes an attribute whose
     * value is a keyword indicating what whitespace processing
     * discipline is intended for the content of the element; its
     * value is inherited.  This name is reserved by virtue of its
     * definition in the XML specification.
     **/
    space: xml.SpaceSchema,
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ColSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('col'),
  attributes: z.object({
    align: ColAlignSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    span: z.string().optional(),
    style: z.string().optional(),
    valign: ColValignSchema.optional(),
    width: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ColgroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('colgroup'),
  attributes: z.object({
    align: ColgroupAlignSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    span: z.string().optional(),
    style: z.string().optional(),
    valign: ColgroupValignSchema.optional(),
    width: z.string().optional(),
  }),
  children: z.array(ColSchema),
})

/** Compound Keyword
 **/
export const CompoundKwdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('compound-kwd'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  children: z.array(CompoundKwdpartSchema),
})

/** Compound Subject Name
 **/
export const CompoundSubjectSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('compound-subject'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  children: z.array(CompoundSubjectpartSchema),
})

/** Conference Information
 **/
export const ConferenceSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('conference'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  children: z.array(
    z.union([
      ConfAcronymSchema,
      ConfDateSchema,
      ConfLocSchema,
      ConfNameSchema,
      ConfNumSchema,
      ConfSponsorSchema,
      ConfThemeSchema,
    ]),
  ),
})

/** Contributor
 **/
export const ContribSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('contrib'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contribType: z.string().optional(),
    corresp: ContribCorrespSchema.optional(),
    deceased: ContribDeceasedSchema.optional(),
    equalContrib: ContribEqualContribSchema.optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    rid: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Contributed Resource Group
 **/
export const ContributedResourcegroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('contributed-resource-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    resourceType: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([AwardGroupSchema, ResourceGroupSchema, SupportDescriptionSchema])),
})

/** Counts
 **/
export const CountsSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('counts'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(
    z.union([
      CountSchema,
      EquationCountSchema,
      FigCountSchema,
      PageCountSchema,
      RefCountSchema,
      TableCountSchema,
      WordCountSchema,
    ]),
  ),
})

/** Custom Metadata
 **/
export const CustomMetaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('custom-meta'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
    vocabTerm: z.string().optional(),
    vocabTermidentifier: z.string().optional(),
  }),
  children: z.array(z.union([MetaNameSchema, MetaValueSchema])),
})

/** Custom Metadata Group
 **/
export const CustomMetagroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('custom-meta-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(CustomMetaSchema),
})

/** Date
 **/
export const DateSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('date'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    calendar: z.string().optional(),
    dateType: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    publicationFormat: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([EraSchema, SeasonSchema, YearSchema])),
})

/** Definition List: Definition Item
 **/
export const DefItemSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('def-item'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([DefSchema, TermSchema])),
})

/** Definition List
 **/
export const DefListSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('def-list'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    continuedFrom: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    listContent: z.string().optional(),
    listType: z.string().optional(),
    prefixWord: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([DefHeadSchema, LabelSchema, TermHeadSchema, TitleSchema])),
})

/** Formula, Display Group
 **/
export const DispFormulagroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('disp-formula-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(LabelSchema),
})

/** Quote, Displayed
 **/
export const DispQuoteSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('disp-quote'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Explanation
 **/
export const ExplanationSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('explanation'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    pointerToexplained: z.string(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([AltTitleSchema, LabelSchema, SubtitleSchema, TitleSchema])),
})

/** Figure
 **/
export const FigSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fig'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    figType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: FigOrientationSchema.optional(),
    position: FigPositionSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Figure Group
 **/
export const FigGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fig-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: FigGroupOrientationSchema.optional(),
    position: FigGroupPositionSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Footnote
 **/
export const FnSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fn'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    customType: z.string().optional(),
    fnType: FnFnTypeSchema.optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    symbol: z.string().optional(),
  }),
  children: z.array(LabelSchema),
})

/** Footnote Group
 **/
export const FnGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('fn-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Funding Group
 **/
export const FundingGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('funding-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([AwardGroupSchema, FundingStatementSchema, OpenAccessSchema])),
})

/** Glossary Elements
 **/
export const GlossarySchema: z.ZodSchema<Glossary> = z.lazy(() =>
  XastElementSchema.extend({
    type: z.literal('element'),
    name: z.literal('glossary'),
    attributes: z.object({
      /** base (as an attribute name)
       * denotes an attribute whose value
       * provides a URI to be used as the base for interpreting any
       * relative URIs in the scope of the element on which it
       * appears; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML Base specification.
       * See http://www.w3.org/TR/xmlbase/
       * for information about this attribute.
       **/
      base: z.string().optional(),
      contentType: z.string().optional(),
      id: z.string().optional(),
      /** lang (as an attribute name)
       * denotes an attribute whose value
       * is a language code for the natural language of the content of
       * any element; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML specification.
       * Notes
       * Attempting to install the relevant ISO 2- and 3-letter
       * codes as the enumerated possible values is probably never
       * going to be a realistic possibility.
       * See BCP 47 at
       * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
       * and the IANA language subtag registry at
       * http://www.iana.org/assignments/language-subtag-registry
       * for further information.
       * The union allows for the 'un-declaration' of xml:lang with
       * the empty string.
       **/
      lang: z.string().optional(),
      specificUse: z.string().optional(),
    }),
    children: z.array(z.union([GlossarySchema, LabelSchema, TitleSchema])),
  }),
)

/** Graphic
 **/
export const GraphicSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('graphic'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    mimeSubtype: z.string().optional(),
    mimetype: z.string().optional(),
    orientation: GraphicOrientationSchema.optional(),
    position: GraphicPositionSchema.optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Index Term
 **/
export const IndexTermSchema: z.ZodSchema<IndexTerm> = z.lazy(() =>
  XastElementSchema.extend({
    type: z.literal('element'),
    name: z.literal('index-term'),
    attributes: z.object({
      /** base (as an attribute name)
       * denotes an attribute whose value
       * provides a URI to be used as the base for interpreting any
       * relative URIs in the scope of the element on which it
       * appears; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML Base specification.
       * See http://www.w3.org/TR/xmlbase/
       * for information about this attribute.
       **/
      base: z.string().optional(),
      contentType: z.string().optional(),
      id: z.string().optional(),
      indexType: z.string().optional(),
      /** lang (as an attribute name)
       * denotes an attribute whose value
       * is a language code for the natural language of the content of
       * any element; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML specification.
       * Notes
       * Attempting to install the relevant ISO 2- and 3-letter
       * codes as the enumerated possible values is probably never
       * going to be a realistic possibility.
       * See BCP 47 at
       * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
       * and the IANA language subtag registry at
       * http://www.iana.org/assignments/language-subtag-registry
       * for further information.
       * The union allows for the 'un-declaration' of xml:lang with
       * the empty string.
       **/
      lang: z.string().optional(),
      specificUse: z.string().optional(),
      vocab: z.string().optional(),
      vocabIdentifier: z.string().optional(),
      vocabTerm: z.string().optional(),
      vocabTermidentifier: z.string().optional(),
    }),
    children: z.array(z.union([IndexTermSchema, TermSchema])),
  }),
)

/** Issue Title Group
 **/
export const IssueTitlegroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('issue-title-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([IssueSubtitleSchema, IssueTitleSchema, TransTitlegroupSchema])),
})

/** Italic
 **/
export const ItalicSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('italic'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: ItalicToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Journal Title Group
 **/
export const JournalTitlegroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('journal-title-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(
    z.union([
      AbbrevJournaltitleSchema,
      JournalSubtitleSchema,
      JournalTitleSchema,
      TransTitlegroupSchema,
    ]),
  ),
})

/** Keyword Group
 **/
export const KwdGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('kwd-group'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    kwdGrouptype: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    vocab: z.string().optional(),
    vocabIdentifier: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** List
 **/
export const ListSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('list'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    continuedFrom: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    listContent: z.string().optional(),
    listType: z.string().optional(),
    prefixWord: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** List Item
 **/
export const ListItemSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('list-item'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Media Object
 **/
export const MediaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('media'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    href: z.string(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    mimeSubtype: z.string().optional(),
    mimetype: z.string().optional(),
    orientation: MediaOrientationSchema.optional(),
    position: MediaPositionSchema.optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Monospace Text (Typewriter Text)
 **/
export const MonospaceSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('monospace'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: MonospaceToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Name of Person (Structured)
 **/
export const NameSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('name'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    nameStyle: NameNameStyleSchema.optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([GivenNamesSchema, PrefixSchema, SuffixSchema])),
})

/** Notes
 **/
export const NotesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('notes'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    notesType: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, SecMetaSchema, TitleSchema])),
})

/** Option Elements
 **/
export const OptionSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('option'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    correct: OptionCorrectSchema.optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([AltTitleSchema, ExplanationSchema, LabelSchema, SubtitleSchema, TitleSchema]),
  ),
})

/** Overline
 **/
export const OverlineSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('overline'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: OverlineToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Person Group For a Cited Publication
 **/
export const PersonGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('person-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    customType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    personGrouptype: PersonGroupPersonGrouptypeSchema.optional(),
    specificUse: z.string().optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Processing Metadata Model
 **/
export const ProcessingMetaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('processing-meta'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    baseTagset: ProcessingMetaBaseTagsetSchema.optional(),
    id: z.string().optional(),
    mathRepresentation: z.string().optional(),
    mathmlVersion: ProcessingMetaMathmlVersionSchema.optional(),
    tableModel: ProcessingMetaTableModelSchema.optional(),
    tagsetFamily: ProcessingMetaTagsetFamilySchema.optional(),
  }),
  children: z.array(z.union([CustomMetagroupSchema, ExtendedBySchema, RestrictedBySchema])),
})

/** Publication Date
 **/
export const PubDateSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('pub-date'),
  attributes: z.object({
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    calendar: z.string().optional(),
    dateType: z.string().optional(),
    id: z.string().optional(),
    iso8601Date: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    pubType: z.string().optional(),
    publicationFormat: z.string().optional(),
  }),
  children: z.array(z.union([EraSchema, SeasonSchema, YearSchema])),
})

/** Publication Identifier For a Cited Publication
 **/
export const PubIdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('pub-id'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    assigningAuthority: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    customType: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    pubIdtype: PubIdPubIdtypeSchema.optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Question
 **/
export const QuestionSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('question'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    questionResponsetype: QuestionQuestionResponsetypeSchema.optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([AltTitleSchema, LabelSchema, SecMetaSchema, SubtitleSchema, TitleSchema]),
  ),
})

/** Question Preamble
 **/
export const QuestionPreambleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('question-preamble'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([AltTitleSchema, LabelSchema, SubtitleSchema, TitleSchema])),
})

/** Question Wrap Group
 **/
export const QuestionWrapgroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('question-wrap-group'),
  attributes: z.object({
    audience: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([AltTitleSchema, LabelSchema, QuestionPreambleSchema, SubtitleSchema, TitleSchema]),
  ),
})

/** Reference List (Bibliographic Reference List)
 **/
export const RefListSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('ref-list'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, RefSchema, TitleSchema])),
})

/** Roman
 **/
export const RomanSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('roman'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: RomanToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Sans Serif
 **/
export const SansSerifSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sans-serif'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: SansSerifToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Small Caps
 **/
export const ScSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sc'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: ScToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Section
 **/
export const SecSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('sec'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    secType: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([SecMetaSchema, TitleSchema])),
})

/** Statement, Formal
 **/
export const StatementSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('statement'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([LabelSchema, TitleSchema])),
})

/** Strike Through
 **/
export const StrikeSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('strike'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    specificUse: z.string().optional(),
    toggle: StrikeToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Styled Special (Subject) Content
 **/
export const StyledContentSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('styled-content'),
  attributes: z.object({
    alt: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
    style: z.string().optional(),
    styleDetail: z.string().optional(),
    styleType: z.string().optional(),
    toggle: StyledContentToggleSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const SubjGroupSchema: z.ZodSchema<SubjGroup> = z.lazy(() =>
  XastElementSchema.extend({
    type: z.literal('element'),
    name: z.literal('subj-group'),
    attributes: z.object({
      assigningAuthority: z.string().optional(),
      /** base (as an attribute name)
       * denotes an attribute whose value
       * provides a URI to be used as the base for interpreting any
       * relative URIs in the scope of the element on which it
       * appears; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML Base specification.
       * See http://www.w3.org/TR/xmlbase/
       * for information about this attribute.
       **/
      base: z.string().optional(),
      id: z.string().optional(),
      /** lang (as an attribute name)
       * denotes an attribute whose value
       * is a language code for the natural language of the content of
       * any element; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML specification.
       * Notes
       * Attempting to install the relevant ISO 2- and 3-letter
       * codes as the enumerated possible values is probably never
       * going to be a realistic possibility.
       * See BCP 47 at
       * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
       * and the IANA language subtag registry at
       * http://www.iana.org/assignments/language-subtag-registry
       * for further information.
       * The union allows for the 'un-declaration' of xml:lang with
       * the empty string.
       **/
      lang: z.string().optional(),
      specificUse: z.string().optional(),
      subjGrouptype: z.string().optional(),
      vocab: z.string().optional(),
      vocabIdentifier: z.string().optional(),
    }),
    children: z.array(z.union([CompoundSubjectSchema, SubjGroupSchema, SubjectSchema])),
  }),
)

/** Support Group
 **/
export const SupportGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('support-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([ContributedResourcegroupSchema, FundingGroupSchema])),
})

/** Table: Table Element ..............................
 **/
export const TableSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('table'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    border: z.string().optional(),
    cellpadding: z.string().optional(),
    cellspacing: z.string().optional(),
    contentType: z.string().optional(),
    frame: TableFrameSchema.optional(),
    id: z.string().optional(),
    rules: TableRulesSchema.optional(),
    specificUse: z.string().optional(),
    style: z.string().optional(),
    summary: z.string().optional(),
    width: z.string().optional(),
  }),
  children: z.array(z.union([ColSchema, ColgroupSchema])),
})

/** Table Wrap Footer
 **/
export const TableWrapfootSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('table-wrap-foot'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(TitleSchema),
})

export const TdSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('td'),
  attributes: z.object({
    abbr: z.string().optional(),
    align: TdAlignSchema.optional(),
    axis: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    colspan: z.string().optional(),
    contentType: z.string().optional(),
    headers: z.string().optional(),
    id: z.string().optional(),
    rowspan: z.string().optional(),
    scope: TdScopeSchema.optional(),
    style: z.string().optional(),
    valign: TdValignSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

export const ThSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('th'),
  attributes: z.object({
    abbr: z.string().optional(),
    align: ThAlignSchema.optional(),
    axis: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    colspan: z.string().optional(),
    contentType: z.string().optional(),
    headers: z.string().optional(),
    id: z.string().optional(),
    rowspan: z.string().optional(),
    scope: ThScopeSchema.optional(),
    style: z.string().optional(),
    valign: ThValignSchema.optional(),
  }),
  /** XastElement is self-closing */
  children: z.tuple([]),
})

/** Title Group
 **/
export const TitleGroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('title-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(
    z.union([
      AltTitleSchema,
      ArticleTitleSchema,
      FnGroupSchema,
      SubtitleSchema,
      TransTitlegroupSchema,
    ]),
  ),
})

export const TrSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('tr'),
  attributes: z.object({
    align: TrAlignSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    style: z.string().optional(),
    valign: TrValignSchema.optional(),
  }),
  children: z.array(z.union([TdSchema, ThSchema])),
})

/** Verse Form For Poetry
 **/
export const VerseGroupSchema: z.ZodSchema<VerseGroup> = z.lazy(() =>
  XastElementSchema.extend({
    type: z.literal('element'),
    name: z.literal('verse-group'),
    attributes: z.object({
      /** base (as an attribute name)
       * denotes an attribute whose value
       * provides a URI to be used as the base for interpreting any
       * relative URIs in the scope of the element on which it
       * appears; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML Base specification.
       * See http://www.w3.org/TR/xmlbase/
       * for information about this attribute.
       **/
      base: z.string().optional(),
      contentType: z.string().optional(),
      id: z.string().optional(),
      /** lang (as an attribute name)
       * denotes an attribute whose value
       * is a language code for the natural language of the content of
       * any element; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML specification.
       * Notes
       * Attempting to install the relevant ISO 2- and 3-letter
       * codes as the enumerated possible values is probably never
       * going to be a realistic possibility.
       * See BCP 47 at
       * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
       * and the IANA language subtag registry at
       * http://www.iana.org/assignments/language-subtag-registry
       * for further information.
       * The union allows for the 'un-declaration' of xml:lang with
       * the empty string.
       **/
      lang: z.string().optional(),
      specificUse: z.string().optional(),
      style: z.string().optional(),
      styleDetail: z.string().optional(),
      styleType: z.string().optional(),
    }),
    children: z.array(
      z.union([LabelSchema, SubtitleSchema, TitleSchema, VerseGroupSchema, VerseLineSchema]),
    ),
  }),
)

/** Translated Title Group
 **/
export const VolumeIssuegroupSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('volume-issue-group'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([
      IssueSchema,
      IssueIdSchema,
      IssuePartSchema,
      IssueSponsorSchema,
      IssueTitleSchema,
      IssueTitlegroupSchema,
      VolumeSchema,
      VolumeIdSchema,
      VolumeSeriesSchema,
    ]),
  ),
})

/** Answer Elements
 **/
export const AnswerSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('answer'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    pointerToquestion: z.string(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([AltTitleSchema, ExplanationSchema, LabelSchema, SubtitleSchema, TitleSchema]),
  ),
})

/** Answer Set
 **/
export const AnswerSetSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('answer-set'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([
      AltTitleSchema,
      AnswerSchema,
      ExplanationSchema,
      LabelSchema,
      SubtitleSchema,
      TitleSchema,
    ]),
  ),
})

/** Article Grouping Data
 **/
export const ArticleCategoriesSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('article-categories'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(z.union([SeriesTextSchema, SeriesTitleSchema, SubjGroupSchema])),
})

/** Article Metadata
 **/
export const ArticleMetaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('article-meta'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(
    z.union([
      ArticleCategoriesSchema,
      ArticleIdSchema,
      AuthorNotesSchema,
      ConferenceSchema,
      CountsSchema,
      CustomMetagroupSchema,
      ElocationIdSchema,
      FundingGroupSchema,
      HistorySchema,
      IsbnSchema,
      IssueSchema,
      IssueIdSchema,
      IssuePartSchema,
      IssueSponsorSchema,
      IssueTitleSchema,
      IssueTitlegroupSchema,
      PermissionsSchema,
      ProductSchema,
      PubDatenotavailableSchema,
      PubHistorySchema,
      SelfUriSchema,
      SupplementSchema,
      SupplementaryMaterialSchema,
      SupportGroupSchema,
      TitleGroupSchema,
      TransAbstractSchema,
      VolumeSchema,
      VolumeIdSchema,
      VolumeIssuegroupSchema,
      VolumeSeriesSchema,
    ]),
  ),
})

/** Boxed Text
 **/
export const BoxedTextSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('boxed-text'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    orientation: BoxedTextOrientationSchema.optional(),
    position: BoxedTextPositionSchema.optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([CaptionSchema, LabelSchema, SecMetaSchema])),
})

/** Event in Publishing History
 **/
export const EventSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('event'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    eventType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([
      ArticleIdSchema,
      EventDescSchema,
      IsbnSchema,
      IssnSchema,
      IssnLSchema,
      NotesSchema,
      PermissionsSchema,
      PubDatenotavailableSchema,
      SelfUriSchema,
    ]),
  ),
})

/** Stub Front Metadata
 **/
export const FrontStubSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('front-stub'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(
    z.union([
      ArticleCategoriesSchema,
      ArticleIdSchema,
      AuthorNotesSchema,
      ConferenceSchema,
      CountsSchema,
      CustomMetagroupSchema,
      ElocationIdSchema,
      FundingGroupSchema,
      HistorySchema,
      IsbnSchema,
      IssueSchema,
      IssueIdSchema,
      IssuePartSchema,
      IssueSponsorSchema,
      IssueTitleSchema,
      IssueTitlegroupSchema,
      PermissionsSchema,
      ProductSchema,
      PubDatenotavailableSchema,
      PubHistorySchema,
      SelfUriSchema,
      SupplementSchema,
      SupplementaryMaterialSchema,
      SupportGroupSchema,
      TitleGroupSchema,
      TransAbstractSchema,
      VolumeSchema,
      VolumeIdSchema,
      VolumeIssuegroupSchema,
      VolumeSeriesSchema,
    ]),
  ),
})

/** Journal Metadata
 **/
export const JournalMetaSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('journal-meta'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(
    z.union([
      IsbnSchema,
      IssnSchema,
      IssnLSchema,
      JournalIdSchema,
      JournalTitlegroupSchema,
      NotesSchema,
      PublisherSchema,
      SelfUriSchema,
    ]),
  ),
})

/** Nlm Citation Model
 **/
export const NlmCitationSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('nlm-citation'),
  attributes: z.object({
    actuate: xlink.ActuateSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    href: z.string().optional(),
    hreflang: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    publicationFormat: z.string().optional(),
    publicationType: z.string().optional(),
    publisherType: z.string().optional(),
    role: z.string().optional(),
    show: xlink.ShowSchema.optional(),
    specificUse: z.string().optional(),
    title: z.string().optional(),
    type: xlink.TypeSchema.optional(),
  }),
  children: z.array(
    z.union([
      AccessDateSchema,
      AnnotationSchema,
      ArticleTitleSchema,
      CollabSchema,
      CommentSchema,
      ConfDateSchema,
      ConfLocSchema,
      ConfNameSchema,
      EditionSchema,
      FpageSchema,
      IssueSchema,
      LpageSchema,
      PageCountSchema,
      PatentSchema,
      PersonGroupSchema,
      PubIdSchema,
      PublisherLocSchema,
      PublisherNameSchema,
      SeasonSchema,
      SeriesSchema,
      SourceSchema,
      SupplementSchema,
      TransSourceSchema,
      TransTitleSchema,
      VolumeSchema,
      YearSchema,
    ]),
  ),
})

/** Question Wrap
 **/
export const QuestionWrapSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('question-wrap'),
  attributes: z.object({
    audience: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(z.union([AnswerSchema, AnswerSetSchema, ExplanationSchema, QuestionSchema])),
})

export const TbodySchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('tbody'),
  attributes: z.object({
    align: TbodyAlignSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    style: z.string().optional(),
    valign: TbodyValignSchema.optional(),
  }),
  children: z.array(TrSchema),
})

export const TfootSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('tfoot'),
  attributes: z.object({
    align: TfootAlignSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    style: z.string().optional(),
    valign: TfootValignSchema.optional(),
  }),
  children: z.array(TrSchema),
})

export const TheadSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('thead'),
  attributes: z.object({
    align: TheadAlignSchema.optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    char: z.string().optional(),
    charoff: z.string().optional(),
    contentType: z.string().optional(),
    id: z.string().optional(),
    style: z.string().optional(),
    valign: TheadValignSchema.optional(),
  }),
  children: z.array(TrSchema),
})

/** Front Matter
 **/
export const FrontSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('front'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
  }),
  children: z.array(z.union([ArticleMetaSchema, JournalMetaSchema])),
})

/** Response
 **/
export const ResponseSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('response'),
  attributes: z.object({
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    responseType: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([
      BackSchema,
      BodySchema,
      FloatsGroupSchema,
      FrontSchema,
      FrontStubSchema,
      ProcessingMetaSchema,
    ]),
  ),
})

/** Sub-Article
 **/
export const SubArticleSchema: z.ZodSchema<SubArticle> = z.lazy(() =>
  XastElementSchema.extend({
    type: z.literal('element'),
    name: z.literal('sub-article'),
    attributes: z.object({
      articleType: z.string().optional(),
      /** base (as an attribute name)
       * denotes an attribute whose value
       * provides a URI to be used as the base for interpreting any
       * relative URIs in the scope of the element on which it
       * appears; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML Base specification.
       * See http://www.w3.org/TR/xmlbase/
       * for information about this attribute.
       **/
      base: z.string().optional(),
      id: z.string().optional(),
      /** lang (as an attribute name)
       * denotes an attribute whose value
       * is a language code for the natural language of the content of
       * any element; its value is inherited.  This name is reserved
       * by virtue of its definition in the XML specification.
       * Notes
       * Attempting to install the relevant ISO 2- and 3-letter
       * codes as the enumerated possible values is probably never
       * going to be a realistic possibility.
       * See BCP 47 at
       * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
       * and the IANA language subtag registry at
       * http://www.iana.org/assignments/language-subtag-registry
       * for further information.
       * The union allows for the 'un-declaration' of xml:lang with
       * the empty string.
       **/
      lang: z.string().optional(),
      specificUse: z.string().optional(),
    }),
    children: z.array(
      z.union([
        BackSchema,
        BodySchema,
        FloatsGroupSchema,
        FrontSchema,
        FrontStubSchema,
        ProcessingMetaSchema,
        ResponseSchema,
        SubArticleSchema,
      ]),
    ),
  }),
)

/** Article
 **/
export const ArticleSchema = XastElementSchema.extend({
  type: z.literal('element'),
  name: z.literal('article'),
  attributes: z.object({
    articleType: z.string().optional(),
    /** base (as an attribute name)
     * denotes an attribute whose value
     * provides a URI to be used as the base for interpreting any
     * relative URIs in the scope of the element on which it
     * appears; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML Base specification.
     * See http://www.w3.org/TR/xmlbase/
     * for information about this attribute.
     **/
    base: z.string().optional(),
    dtdVersion: ArticleDtdVersionSchema.optional(),
    id: z.string().optional(),
    /** lang (as an attribute name)
     * denotes an attribute whose value
     * is a language code for the natural language of the content of
     * any element; its value is inherited.  This name is reserved
     * by virtue of its definition in the XML specification.
     * Notes
     * Attempting to install the relevant ISO 2- and 3-letter
     * codes as the enumerated possible values is probably never
     * going to be a realistic possibility.
     * See BCP 47 at
     * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
     * and the IANA language subtag registry at
     * http://www.iana.org/assignments/language-subtag-registry
     * for further information.
     * The union allows for the 'un-declaration' of xml:lang with
     * the empty string.
     **/
    lang: z.string().optional(),
    specificUse: z.string().optional(),
  }),
  children: z.array(
    z.union([
      BackSchema,
      BodySchema,
      FloatsGroupSchema,
      FrontSchema,
      ProcessingMetaSchema,
      ResponseSchema,
      SubArticleSchema,
    ]),
  ),
})
