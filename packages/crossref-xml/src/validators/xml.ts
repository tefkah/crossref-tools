import * as Primitive from './Primitive'
// Generated by ts-to-zod
import { z } from 'zod'

// Source files:
// https://data.crossref.org/schemas/standard-modules/xml.xsd
export const XastAttributesSchema = z.record(z.union([z.string(), z.undefined()]).nullable())

const XastTextSchema = z.object({
  type: z.literal('text'),
  value: z.string(),
})

const XastCommentSchema = z.object({
  type: z.literal('comment'),
  value: z.string(),
})

const XastCDataSchema = z.object({
  type: z.literal('cdata'),
  value: z.string(),
})

const XastInstructionSchema = z.object({
  type: z.literal('instruction'),
  name: z.string(),
  value: z.string(),
})

const FakerXastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      z.object({
        type: z.string(),
        name: z.string().optional(),
        attributes: z.record(z.any()).optional(),
        children: z.array(z.any()),
      }),
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

const FakeXastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      FakerXastElementSchema,
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

export const XastElementSchema = z.object({
  type: z.literal('element'),
  name: z.string(),
  attributes: z.union([XastAttributesSchema, z.undefined()]).optional(),
  children: z.array(
    z.union([
      FakeXastElementSchema,
      XastTextSchema,
      XastCommentSchema,
      XastInstructionSchema,
      XastCDataSchema,
    ]),
  ),
})

const XastTextElementSchema = XastElementSchema.extend({
  children: z.tuple([XastTextSchema]),
})

/** base (as an attribute name)
 * denotes an attribute whose value
 * provides a URI to be used as the base for interpreting any
 * relative URIs in the scope of the element on which it
 * appears; its value is inherited.  This name is reserved
 * by virtue of its definition in the XML Base specification.
 * See http://www.w3.org/TR/xmlbase/
 * for information about this attribute.
 **/
export const BaseSchema = XastElementSchema.extend({
  name: z.literal('base'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** id (as an attribute name)
 * denotes an attribute whose value
 * should be interpreted as if declared to be of type ID.
 * This name is reserved by virtue of its definition in the
 * xml:id specification.
 * See http://www.w3.org/TR/xml-id/
 * for information about this attribute.
 **/
export const IdSchema = XastElementSchema.extend({
  name: z.literal('id'),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** lang (as an attribute name)
 * denotes an attribute whose value
 * is a language code for the natural language of the content of
 * any element; its value is inherited.  This name is reserved
 * by virtue of its definition in the XML specification.
 * Notes
 * Attempting to install the relevant ISO 2- and 3-letter
 * codes as the enumerated possible values is probably never
 * going to be a realistic possibility.
 * See BCP 47 at
 * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
 * and the IANA language subtag registry at
 * http://www.iana.org/assignments/language-subtag-registry
 * for further information.
 * The union allows for the 'un-declaration' of xml:lang with
 * the empty string.
 **/
export const LangSchema = XastElementSchema.extend({
  name: z.string(),
  children: z.tuple([
    z.object({
      type: z.literal('text'),
      value: z.string(),
    }),
  ]),
})

/** lang (as an attribute name)
 * denotes an attribute whose value
 * is a language code for the natural language of the content of
 * any element; its value is inherited.  This name is reserved
 * by virtue of its definition in the XML specification.
 * Notes
 * Attempting to install the relevant ISO 2- and 3-letter
 * codes as the enumerated possible values is probably never
 * going to be a realistic possibility.
 * See BCP 47 at
 * http://www.rfc-editor.org/rfc/bcp/bcp47.txt
 * and the IANA language subtag registry at
 * http://www.iana.org/assignments/language-subtag-registry
 * for further information.
 * The union allows for the 'un-declaration' of xml:lang with
 * the empty string.
 **/
export const LangPrimitiveTypeSchema = z.string()

/** space (as an attribute name)
 * denotes an attribute whose
 * value is a keyword indicating what whitespace processing
 * discipline is intended for the content of the element; its
 * value is inherited.  This name is reserved by virtue of its
 * definition in the XML specification.
 **/
export const SpaceSchema = z.union([z.literal('default'), z.literal('preserve')])
